From dd9a57a21673747f6815f09d5259deca7a81f778 Mon Sep 17 00:00:00 2001
From: "Tsuchiya Yuto (kitakar5525)" <kitakar@gmail.com>
Date: Mon, 20 Apr 2020 22:09:16 +0900
Subject: [PATCH 1/5] Revert "wireless/mwifiex: Fix S0ix / suspend"

This reverts commit 456cdc416f6e68a8a2e58e65b70838a18a17aa77.

Reason for revert:
  This commit will be split into smaller commits to describe what each
  commit does. Currently, this commit does the following things within
  this one commit:
  a) modify mwifiex_pcie_suspend/mwifiex_pcie_resume functions to
     achieve S0ix without user unloading mwifiex module manually
     and also to fix "(sometimes) scanning for APs doesn't work after
     suspend"
  b) disable bridge_d3 to fix mwifiex module crashing after suspend
  c) disable "auto deep sleep" (auto_ds). auto_ds is reportedly causing
     "suspend/resume fails when not connected to an Access Point."

Signed-off-by: Tsuchiya Yuto (kitakar5525) <kitakar@gmail.com>
---
 drivers/net/wireless/marvell/mwifiex/pcie.c   | 74 +++++++++----------
 .../net/wireless/marvell/mwifiex/sta_cmd.c    | 15 +++-
 2 files changed, 48 insertions(+), 41 deletions(-)

diff --git a/drivers/net/wireless/marvell/mwifiex/pcie.c b/drivers/net/wireless/marvell/mwifiex/pcie.c
index b3380ed754313..fc1706d0647d7 100644
--- a/drivers/net/wireless/marvell/mwifiex/pcie.c
+++ b/drivers/net/wireless/marvell/mwifiex/pcie.c
@@ -149,38 +149,35 @@ static bool mwifiex_pcie_ok_to_access_hw(struct mwifiex_adapter *adapter)
  */
 static int mwifiex_pcie_suspend(struct device *dev)
 {
-	struct pci_dev *pdev = to_pci_dev(dev);
-	struct pcie_service_card *card = pci_get_drvdata(pdev);
 	struct mwifiex_adapter *adapter;
-	struct mwifiex_private *priv;
-	const struct mwifiex_pcie_card_reg *reg;
-	u32 fw_status;
-	int ret;
+	struct pcie_service_card *card = dev_get_drvdata(dev);
+
 
 	/* Might still be loading firmware */
 	wait_for_completion(&card->fw_done);
 
 	adapter = card->adapter;
-	if (!adapter || !adapter->priv_num)
+	if (!adapter) {
+		dev_err(dev, "adapter is not valid\n");
 		return 0;
+	}
 
-	reg = card->pcie.reg;
-	if (reg)
-		ret = mwifiex_read_reg(adapter, reg->fw_status, &fw_status);
-	else
-		fw_status = -1;
-
-	if (fw_status == FIRMWARE_READY_PCIE && !adapter->mfg_mode) {
-		mwifiex_deauthenticate_all(adapter);
-
-		priv = mwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_ANY);
-
-		mwifiex_disable_auto_ds(priv);
+	mwifiex_enable_wake(adapter);
 
-		mwifiex_init_shutdown_fw(priv, MWIFIEX_FUNC_SHUTDOWN);
+	/* Enable the Host Sleep */
+	if (!mwifiex_enable_hs(adapter)) {
+		mwifiex_dbg(adapter, ERROR,
+			    "cmd: failed to suspend\n");
+		clear_bit(MWIFIEX_IS_HS_ENABLING, &adapter->work_flags);
+		mwifiex_disable_wake(adapter);
+		return -EFAULT;
 	}
 
-	mwifiex_remove_card(adapter);
+	flush_workqueue(adapter->workqueue);
+
+	/* Indicate device suspended */
+	set_bit(MWIFIEX_IS_SUSPENDED, &adapter->work_flags);
+	clear_bit(MWIFIEX_IS_HS_ENABLING, &adapter->work_flags);
 
 	return 0;
 }
@@ -195,29 +192,28 @@ static int mwifiex_pcie_suspend(struct device *dev)
  */
 static int mwifiex_pcie_resume(struct device *dev)
 {
-	struct pci_dev *pdev = to_pci_dev(dev);
-	struct pcie_service_card *card = pci_get_drvdata(pdev);
-	int ret;
+	struct mwifiex_adapter *adapter;
+	struct pcie_service_card *card = dev_get_drvdata(dev);
 
-	pr_debug("info: vendor=0x%4.04X device=0x%4.04X rev=%d\n",
-		 pdev->vendor, pdev->device, pdev->revision);
 
-	init_completion(&card->fw_done);
+	if (!card->adapter) {
+		dev_err(dev, "adapter structure is not valid\n");
+		return 0;
+	}
 
-	card->dev = pdev;
+	adapter = card->adapter;
 
-	/* device tree node parsing and platform specific configuration */
-	if (pdev->dev.of_node) {
-		ret = mwifiex_pcie_probe_of(&pdev->dev);
-		if (ret)
-			return ret;
+	if (!test_bit(MWIFIEX_IS_SUSPENDED, &adapter->work_flags)) {
+		mwifiex_dbg(adapter, WARN,
+			    "Device already resumed\n");
+		return 0;
 	}
 
-	if (mwifiex_add_card(card, &card->fw_done, &pcie_ops,
-			MWIFIEX_PCIE, &pdev->dev)) {
-		pr_err("%s failed\n", __func__);
-		return -1;
-	}
+	clear_bit(MWIFIEX_IS_SUSPENDED, &adapter->work_flags);
+
+	mwifiex_cancel_hs(mwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_STA),
+			  MWIFIEX_ASYNC_CMD);
+	mwifiex_disable_wake(adapter);
 
 	return 0;
 }
@@ -271,8 +267,6 @@ static int mwifiex_pcie_probe(struct pci_dev *pdev,
 		return -1;
 	}
 
-	pdev->bus->self->bridge_d3 = false;
-
 	return 0;
 }
 
diff --git a/drivers/net/wireless/marvell/mwifiex/sta_cmd.c b/drivers/net/wireless/marvell/mwifiex/sta_cmd.c
index 977b57c0908fb..070205a905635 100644
--- a/drivers/net/wireless/marvell/mwifiex/sta_cmd.c
+++ b/drivers/net/wireless/marvell/mwifiex/sta_cmd.c
@@ -2265,13 +2265,14 @@ int mwifiex_sta_prepare_cmd(struct mwifiex_private *priv, uint16_t cmd_no,
 int mwifiex_sta_init_cmd(struct mwifiex_private *priv, u8 first_sta, bool init)
 {
 	struct mwifiex_adapter *adapter = priv->adapter;
+	int ret;
 	struct mwifiex_ds_11n_amsdu_aggr_ctrl amsdu_aggr_ctrl;
+	struct mwifiex_ds_auto_ds auto_ds;
 	enum state_11d_t state_11d;
 	struct mwifiex_ds_11n_tx_cfg tx_cfg;
 	u8 sdio_sp_rx_aggr_enable;
 	u16 packet_aggr_enable;
 	int data;
-	int ret;
 
 	if (first_sta) {
 		if (priv->adapter->iface_type == MWIFIEX_PCIE) {
@@ -2383,6 +2384,18 @@ int mwifiex_sta_init_cmd(struct mwifiex_private *priv, u8 first_sta, bool init)
 	if (ret)
 		return -1;
 
+	if (!disable_auto_ds && first_sta &&
+	    priv->bss_type != MWIFIEX_BSS_TYPE_UAP) {
+		/* Enable auto deep sleep */
+		auto_ds.auto_ds = DEEP_SLEEP_ON;
+		auto_ds.idle_time = DEEP_SLEEP_IDLE_TIME;
+		ret = mwifiex_send_cmd(priv, HostCmd_CMD_802_11_PS_MODE_ENH,
+				       EN_AUTO_PS, BITMAP_AUTO_DS,
+				       &auto_ds, true);
+		if (ret)
+			return -1;
+	}
+
 	if (priv->bss_type != MWIFIEX_BSS_TYPE_UAP) {
 		/* Send cmd to FW to enable/disable 11D function */
 		state_11d = ENABLE_11D;
-- 
2.26.2

