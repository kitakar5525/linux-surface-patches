From 79771833fb6ad23b3beefb0451a34fa32b5f8c67 Mon Sep 17 00:00:00 2001
From: "Tsuchiya Yuto (kitakar5525)" <kitakar@gmail.com>
Date: Mon, 20 Apr 2020 22:12:46 +0900
Subject: [PATCH 07/10] mwifiex_pcie: remove()/probe() card on
 suspend()/resume()

(made based on commit https://github.com/sebanc/linux-kernel/commit/0f5283b42247cb8978ed9493936f9b5b72350121)

On upstream mwifiex driver, it's reported that unloading the driver
manually [1] fixes S0ix achievement during s2idle (suspend).

Also, unloading/reloading the driver fixes "AP scanning (sometimes) not
working after suspend".

This commit removes/probes the card on suspend/resume on the driver
side to fix such issues.

[1] Run the following command for example
    $ sudo modprobe -r mwifiex_pcie
      sudo modprobe -r mwifiex

Signed-off-by: Tsuchiya Yuto (kitakar5525) <kitakar@gmail.com>

(cherry picked from commit 82204f8a30b24dfb80a926796359c4692c4d660e
from PR #44)
Signed-off-by: Tsuchiya Yuto (kitakar5525) <kitakar@gmail.com>
---
 drivers/net/wireless/marvell/mwifiex/pcie.c | 79 ++++++++++++---------
 1 file changed, 45 insertions(+), 34 deletions(-)

diff --git a/drivers/net/wireless/marvell/mwifiex/pcie.c b/drivers/net/wireless/marvell/mwifiex/pcie.c
index 2aa0436d3548b..60f8a9eb31184 100644
--- a/drivers/net/wireless/marvell/mwifiex/pcie.c
+++ b/drivers/net/wireless/marvell/mwifiex/pcie.c
@@ -146,38 +146,45 @@ static bool mwifiex_pcie_ok_to_access_hw(struct mwifiex_adapter *adapter)
  *
  * If already not suspended, this function allocates and sends a host
  * sleep activate request to the firmware and turns off the traffic.
+ *
+ * XXX: ignoring all the above comment and just removes the card to
+ * fix S0ix and "AP scanning (sometimes) not working after suspend".
+ * Required code is extracted from mwifiex_pcie_remove().
  */
 static int mwifiex_pcie_suspend(struct device *dev)
 {
+	struct pci_dev *pdev = to_pci_dev(dev);
+	struct pcie_service_card *card = pci_get_drvdata(pdev);
 	struct mwifiex_adapter *adapter;
-	struct pcie_service_card *card = dev_get_drvdata(dev);
-
+	struct mwifiex_private *priv;
+	const struct mwifiex_pcie_card_reg *reg;
+	u32 fw_status;
+	int ret;
 
 	/* Might still be loading firmware */
 	wait_for_completion(&card->fw_done);
 
 	adapter = card->adapter;
-	if (!adapter) {
-		dev_err(dev, "adapter is not valid\n");
+	if (!adapter || !adapter->priv_num)
 		return 0;
-	}
 
-	mwifiex_enable_wake(adapter);
+	reg = card->pcie.reg;
+	if (reg)
+		ret = mwifiex_read_reg(adapter, reg->fw_status, &fw_status);
+	else
+		fw_status = -1;
+
+	if (fw_status == FIRMWARE_READY_PCIE && !adapter->mfg_mode) {
+		mwifiex_deauthenticate_all(adapter);
+
+		priv = mwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_ANY);
 
-	/* Enable the Host Sleep */
-	if (!mwifiex_enable_hs(adapter)) {
-		mwifiex_dbg(adapter, ERROR,
-			    "cmd: failed to suspend\n");
-		clear_bit(MWIFIEX_IS_HS_ENABLING, &adapter->work_flags);
-		mwifiex_disable_wake(adapter);
-		return -EFAULT;
-	}
+		mwifiex_disable_auto_ds(priv);
 
-	flush_workqueue(adapter->workqueue);
+		mwifiex_init_shutdown_fw(priv, MWIFIEX_FUNC_SHUTDOWN);
+	}
 
-	/* Indicate device suspended */
-	set_bit(MWIFIEX_IS_SUSPENDED, &adapter->work_flags);
-	clear_bit(MWIFIEX_IS_HS_ENABLING, &adapter->work_flags);
+	mwifiex_remove_card(adapter);
 
 	return 0;
 }
@@ -189,31 +196,35 @@ static int mwifiex_pcie_suspend(struct device *dev)
  *
  * If already not resumed, this function turns on the traffic and
  * sends a host sleep cancel request to the firmware.
+ *
+ * XXX: ignoring all the above comment and probes the card that was
+ * removed on suspend. Required code is extracted from mwifiex_pcie_probe().
  */
 static int mwifiex_pcie_resume(struct device *dev)
 {
-	struct mwifiex_adapter *adapter;
-	struct pcie_service_card *card = dev_get_drvdata(dev);
+	struct pci_dev *pdev = to_pci_dev(dev);
+	struct pcie_service_card *card = pci_get_drvdata(pdev);
+	int ret;
 
+	pr_debug("info: vendor=0x%4.04X device=0x%4.04X rev=%d\n",
+		 pdev->vendor, pdev->device, pdev->revision);
 
-	if (!card->adapter) {
-		dev_err(dev, "adapter structure is not valid\n");
-		return 0;
-	}
+	init_completion(&card->fw_done);
 
-	adapter = card->adapter;
+	card->dev = pdev;
 
-	if (!test_bit(MWIFIEX_IS_SUSPENDED, &adapter->work_flags)) {
-		mwifiex_dbg(adapter, WARN,
-			    "Device already resumed\n");
-		return 0;
+	/* device tree node parsing and platform specific configuration */
+	if (pdev->dev.of_node) {
+		ret = mwifiex_pcie_probe_of(&pdev->dev);
+		if (ret)
+			return ret;
 	}
 
-	clear_bit(MWIFIEX_IS_SUSPENDED, &adapter->work_flags);
-
-	mwifiex_cancel_hs(mwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_STA),
-			  MWIFIEX_ASYNC_CMD);
-	mwifiex_disable_wake(adapter);
+	if (mwifiex_add_card(card, &card->fw_done, &pcie_ops,
+			MWIFIEX_PCIE, &pdev->dev)) {
+		pr_err("%s failed\n", __func__);
+		return -1;
+	}
 
 	return 0;
 }
-- 
2.26.2

