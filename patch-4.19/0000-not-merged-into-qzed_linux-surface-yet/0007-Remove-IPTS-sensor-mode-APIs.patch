From 5b4f28a279451bdfd44a19a9ef66551bb0104a79 Mon Sep 17 00:00:00 2001
From: Dorian Stoll <dorian.stoll@tmsp.io>
Date: Wed, 18 Sep 2019 22:35:26 +0200
Subject: [PATCH 7/8] Remove IPTS sensor mode APIs

The previous commit reverted the changes to hid-multitouch that were done by
the IPTS patch. The original implementation modified hid-multitouch to make the
single-touch mode work. However, window managers such as GNOME's mutter cannot
differentiate between two touchscreens on the same panel. This results in broken
touch input rotation (the single-touch panel gets rotated, even if it is not
active).

https://github.com/jakeday/linux-surface/issues/549 had some discussion on this
and multiple fixes. But I think the less changes to unrelated kernel code, the
better. I don't think that anyone actually uses single-touch mode.

Since single-touch mode was disabled by the previous commit, remove all user-
space APIs to enable it, since that just sends all touch input to /dev/null

Because IPTS does switch it's mode during initialization, it is not possible to
remove all references to the sensor mode, at least not without a more in-depth
review.

Signed-off-by: Dorian Stoll <dorian.stoll@tmsp.io>
---
 drivers/misc/ipts/ipts-dbgfs.c       | 77 +---------------------------
 drivers/misc/ipts/ipts-mei.c         | 40 ---------------
 drivers/misc/ipts/ipts-msg-handler.c | 11 ----
 drivers/misc/ipts/ipts-msg-handler.h |  1 -
 4 files changed, 2 insertions(+), 127 deletions(-)

diff --git a/drivers/misc/ipts/ipts-dbgfs.c b/drivers/misc/ipts/ipts-dbgfs.c
index 7581b21f8..ffa42a333 100644
--- a/drivers/misc/ipts/ipts-dbgfs.c
+++ b/drivers/misc/ipts/ipts-dbgfs.c
@@ -22,76 +22,11 @@
 #include "ipts-state.h"
 #include "../mei/mei_dev.h"
 
-const char sensor_mode_fmt[] = "sensor mode : %01d\n";
-const char ipts_status_fmt[] = "sensor mode : %01d\nipts state : %01d\n";
+const char ipts_status_fmt[] = "ipts state : %01d\n";
 const char ipts_debug_fmt[] = ">> tdt : fw status : %s\n"
 							  ">> == DB s:%x, c:%x ==\n"
 							  ">> == WQ h:%u, t:%u ==\n";
 
-static ssize_t ipts_dbgfs_mode_read(struct file *fp, char __user *ubuf,
-						size_t cnt, loff_t *ppos)
-{
-	ipts_info_t *ipts = fp->private_data;
-	char mode[80];
-	int len = 0;
-
-	if (cnt < sizeof(sensor_mode_fmt) - 3)
-		return -EINVAL;
-
-	len = scnprintf(mode, 80, sensor_mode_fmt, ipts->sensor_mode);
-	if (len < 0)
-		return -EIO;
-
-	return simple_read_from_buffer(ubuf, cnt, ppos, mode, len);
-}
-
-static ssize_t ipts_dbgfs_mode_write(struct file *fp, const char __user *ubuf,
-						size_t cnt, loff_t *ppos)
-{
-	ipts_info_t *ipts = fp->private_data;
-	ipts_state_t state;
-	int sensor_mode, len;
-	char mode[3];
-
-	if (cnt == 0 || cnt > 3)
-		return -EINVAL;
-
-	state = ipts_get_state(ipts);
-	if (state != IPTS_STA_RAW_DATA_STARTED && state != IPTS_STA_HID_STARTED) {
-		return -EIO;
-	}
-
-	len = cnt;
-	if (copy_from_user(mode, ubuf, len))
-		return -EFAULT;
-
-	while(len > 0 && (isspace(mode[len-1]) || mode[len-1] == '\n'))
-		len--;
-	mode[len] = '\0';
-
-	if (sscanf(mode, "%d", &sensor_mode) != 1)
-		return -EINVAL;
-
-	if (sensor_mode != TOUCH_SENSOR_MODE_RAW_DATA &&
-					sensor_mode != TOUCH_SENSOR_MODE_HID) {
-		return -EINVAL;
-	}
-
-	if (sensor_mode == ipts->sensor_mode)
-		return 0;
-
-	ipts_switch_sensor_mode(ipts, sensor_mode);
-
-	return cnt;
-}
-
-static const struct file_operations ipts_mode_dbgfs_fops = {
-        .open = simple_open,
-        .read = ipts_dbgfs_mode_read,
-        .write = ipts_dbgfs_mode_write,
-        .llseek = generic_file_llseek,
-};
-
 static ssize_t ipts_dbgfs_status_read(struct file *fp, char __user *ubuf,
 						size_t cnt, loff_t *ppos)
 {
@@ -102,8 +37,7 @@ static ssize_t ipts_dbgfs_status_read(struct file *fp, char __user *ubuf,
 	if (cnt < sizeof(ipts_status_fmt) - 3)
 		return -EINVAL;
 
-	len = scnprintf(status, 256, ipts_status_fmt, ipts->sensor_mode,
-						     ipts->state);
+	len = scnprintf(status, 256, ipts_status_fmt, ipts->state);
 	if (len < 0)
 		return -EIO;
 
@@ -299,13 +233,6 @@ int ipts_dbgfs_register(ipts_info_t* ipts, const char *name)
 	if (!dir)
 		return -ENOMEM;
 
-        f = debugfs_create_file("mode", S_IRUSR | S_IWUSR, dir,
-                                ipts, &ipts_mode_dbgfs_fops);
-        if (!f) {
-                ipts_err(ipts, "debugfs mode creation failed\n");
-                goto err;
-        }
-
         f = debugfs_create_file("status", S_IRUSR, dir,
                                 ipts, &ipts_status_dbgfs_fops);
         if (!f) {
diff --git a/drivers/misc/ipts/ipts-mei.c b/drivers/misc/ipts/ipts-mei.c
index 6fbe257bc..7773b8783 100644
--- a/drivers/misc/ipts/ipts-mei.c
+++ b/drivers/misc/ipts/ipts-mei.c
@@ -39,43 +39,6 @@ static struct mei_cl_device_id ipts_mei_cl_tbl[] = {
 	{}
 };
 
-static ssize_t sensor_mode_show(struct device *dev,
-				struct device_attribute *attr, char *buf)
-{
-	ipts_info_t *ipts;
-	ipts = dev_get_drvdata(dev);
-
-	return sprintf(buf, "%d\n", ipts->sensor_mode);
-}
-
-//TODO: Verify the function implementation
-static ssize_t sensor_mode_store(struct device *dev,
-				struct device_attribute *attr, const char *buf,
-				size_t count)
-{
-	int ret;
-	long val;
-	ipts_info_t *ipts;
-
-	ipts = dev_get_drvdata(dev);
-	ret = kstrtol(buf, 10, &val);
-	if (ret)
-	   return ret;
-
-	ipts_dbg(ipts, "try sensor mode = %ld\n", val);
-
-	switch (val) {
-		case TOUCH_SENSOR_MODE_HID:
-			break;
-		case TOUCH_SENSOR_MODE_RAW_DATA:
-			break;
-		default:
-			ipts_err(ipts, "sensor mode %ld is not supported\n", val);
-	}
-
-	return count;
-}
-
 static ssize_t device_info_show(struct device *dev,
 				struct device_attribute *attr, char *buf)
 {
@@ -89,12 +52,9 @@ static ssize_t device_info_show(struct device *dev,
 			ipts->device_info.vendor_id, ipts->device_info.device_id,
 			ipts->device_info.hw_rev, ipts->device_info.fw_rev);
 }
-
-static DEVICE_ATTR_RW(sensor_mode);
 static DEVICE_ATTR_RO(device_info);
 
 static struct attribute *ipts_attrs[] = {
-	&dev_attr_sensor_mode.attr,
 	&dev_attr_device_info.attr,
 	NULL
 };
diff --git a/drivers/misc/ipts/ipts-msg-handler.c b/drivers/misc/ipts/ipts-msg-handler.c
index db5356a1c..6ca74dd70 100644
--- a/drivers/misc/ipts/ipts-msg-handler.c
+++ b/drivers/misc/ipts/ipts-msg-handler.c
@@ -189,17 +189,6 @@ int ipts_restart(ipts_info_t *ipts)
 	return ret;
 }
 
-int ipts_switch_sensor_mode(ipts_info_t *ipts, int new_sensor_mode)
-{
-	int ret = 0;
-
-        ipts->new_sensor_mode = new_sensor_mode;
-	ipts->switch_sensor_mode = true;
-        ret = ipts_send_sensor_quiesce_io_cmd(ipts);
-
-	return ret;
-}
-
 #define rsp_failed(ipts, cmd, status) ipts_err(ipts, \
 				"0x%08x failed status = %d\n", cmd, status);
 
diff --git a/drivers/misc/ipts/ipts-msg-handler.h b/drivers/misc/ipts/ipts-msg-handler.h
index f37d9ad9a..4ee8301db 100644
--- a/drivers/misc/ipts/ipts-msg-handler.h
+++ b/drivers/misc/ipts/ipts-msg-handler.h
@@ -20,7 +20,6 @@
 int ipts_handle_cmd(ipts_info_t *ipts, u32 cmd, void *data, int data_size);
 int ipts_start(ipts_info_t *ipts);
 void ipts_stop(ipts_info_t *ipts);
-int ipts_switch_sensor_mode(ipts_info_t *ipts, int new_sensor_mode);
 int ipts_handle_resp(ipts_info_t *ipts, touch_sensor_msg_m2h_t *m2h_msg,
                      u32 msg_len);
 int ipts_handle_processed_data(ipts_info_t *ipts);
-- 
2.24.1

